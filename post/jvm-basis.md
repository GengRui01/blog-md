---
title: "JVM知识点整理"
tags: ["Java", "Interview"]
date: 2019-10-01
---

JVM相关知识点整理

<!--more-->

## 类的生命周期

类的生命周期如下图所示：

![image](/media/posts/jvm-basis/1.png)

- 加载
    1. 找到类文件（通过类的全限定名来获取定义此类的二进制字节流）
    2. 放入方法区（将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构）
    3. 开个入口（生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口）

- 连接

    连接分为三步，如下图所示：

    ![image](/media/posts/jvm-basis/2.jpg)

    - 校验（检查Class文件的字节流中包含的信息是否符合当前虚拟机的要求）
    - 准备（为静态变量和静态常量分配内存，并给静态常量赋设定值，静态变量赋初始值）
    - 解析（jvm将常量池的符号引用替换为直接引用）

- 初始化
    为静态变量赋程序设定的初值，类只有在如下五种情况下会初始化：
    1. 使用new关键字创建类的实例，或读取或设置一个静态字段的值，或调用静态方法的时候
    2. 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化
    3. 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化
    4. 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类
    5. 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REFgetStatic、REFputStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化

## 类加载机制

上述生命周期中的加载阶段就是类加载器在做，JVM自带的加载器有三种，他们的继承关系如下图所示：

![image](/media/posts/jvm-basis/3.jpg)

类的加载机制是双亲委派机制，工作过程如下：

1. 当前加载器从自己的缓存中查询是否此类已经加载，有就返回加载好的类（每个类加载器都有自己的加载缓存，已经加载的类都会放入缓存中）
2. 当前加载器的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到应用程序类加载器
3. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回

## JVM内存模型

内存模型包含如下五个区域：

![image](/media/posts/jvm-basis/4.jpg)

最主要的三块及其用途如下：

- 堆：存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域
- 栈：Java 方法执行的内存模型：存储局部变量表，操作数栈，动态链接，方法出口等信息。生命周期与线程相同
- 方法区：存储虚拟机加载的类信息，常量，静态变量等数据

## 判断对象是否要回收

1. 引用计数法

- 做法：给对象添加一个引用计数器，每当有一个地方引用该对象，这个计数器就加1。当引用失效时，计数器就减1。如果计数器为0了，说明该对象不再被引用，成为死亡对象，需要被回收
- 缺点：无法处理对象相互引用（假如有A、B两个对象，它们互相引用，那么对象中的引用计数器会始终大于0）

2. 可达性分析法

- 做法：通过一系列被称为“GC Roots”的对象作为起点，从这些起点开始往下搜索，搜索所走过的路径称为引用链。当一个对象没有和任何引用链相连，即称为该对象不可达，认为该对象死亡
- GC Roots对象：当前所有正在被调用的方法的引用类型的参数/局部变量/临时值
    - 栈（栈帧中的本地变量表）中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI引用的对象
- 引用：
    - 强引用：日常开发中最常见的引用，只要强引用还在对象就不会被回收
    - 软引用：需要用“SoftReference”专门申明，被软引用关联的对象在内存不足时会被回收
    - 弱引用：需要用“WeakReference”专门申明，弱引用的对象每次GC时都会被回收
    - 虚引用：需要用“PhantomReference”专门申明，虚引用完全不会影响对象的生存时间，唯一的作用是在对象被回收时发一个系统通知

## 垃圾回收机制

- 根据对象存活的生命周期将内存划分为新生代、老年代和永久代三个区域
    - 新生代：存放新创建的对象，对象生命周期非常短，几乎用完可以立即回收，所以每次垃圾回收时都有大量的对象需要被回收
    - 老年代：新生代中多次回收后存活下来的对象将被移到老年代区
    - 永久带：主要存加载的类信息，生命周期长，几乎不会被回收
- 垃圾回收算法
    - 标记—清除算法：1. 确定所有要回收的对象，并做标记  2.将标记阶段确定不可用的对象清除
    - 复制算法：内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候， 把存活的对象复制到另一块上，然后把这块内存整个清理掉
    - 标记—整理算法：把存活对象往内存的一端移动，然后直接回收边界以外的内存