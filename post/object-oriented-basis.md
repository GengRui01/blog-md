---
title: "面向对象知识点整理"
tags: ["Java", "Interview"]
date: 2019-10-01
---

之前整理了Java基础的知识点，这篇文章就来整理一下面向对象相关的知识点。

<!--more-->

## 成员变量 局部变量

- 成员变量是指在类中定义的变量
- 局部变量是指在方法中定义的变量

具体变量分类如下图所示：

![image](/media/posts/object-oriented-basis/1.png)

注意：局部变量名和成员变量名相同时 局部变量覆盖成员变量

## 访问控制符

![image](/media/posts/object-oriented-basis/2.png)

关于访问控制符的使用，存在如下几条基本原则：

- 大部分成员变量都应该用private修饰，只有一些需要全局使用的静态变量会用public和static修饰
- 只有父类中的方法仅希望被子类重写且不被外界调用，才使用protected
- 可以被其他类调用的方法用public修饰，仅在该类中使用的方法用private修饰

## 面向对象三大特征

- 封装：将对象的状态信息隐藏在对象内部，可通过该类提供的方法访问或操作内部信息，不允许外界直接访问
- 继承：用extends关键字实现继承，继承的是子类，被继承的是父类
    - 子类可以获得父类的全部成员变量和方法（不能获得父类的构造器，可以通过supper()调用父类构造器）
    - 子类重写父类方法需要两同两小一大（方法名、形参列表相同，返回值类型及抛出异常比父类小或相等，访问权限比父类大或相等）
- 多态
    - 编译类型为父类运行类型为子类的对象，调用子类重写父类的方法后，会表现出子类方法的行为特征
    - 如上就会出现：相同类型的变量调用同一个方法时会呈现出不同的行为特征，这就是多态
    
```java
// 父类
public class Parent {
    public String write(){
        return "Parent";
    }
}
// 子类
public class Children extends Parent {
    public String write(){
        return "Children";
    }
}
// 测试
public void test() {
    Parent parent = new Parent();
    System.out.println("父类编译对象 父类运行对象 " + parent.write());
    Children children = new Children();
    System.out.println("子类编译对象 子类运行对象 " + children.write());
    Parent polymorphism = new Children();
    System.out.println("父类编译对象 子类运行对象 " + polymorphism.write());
}
```

输出结果：

![image](/media/posts/object-oriented-basis/3.png)

其中第一、三行打出的信息不同，即为多态。

也就是说引用变量在编译时并不确定会指向哪一个实例对象，只有在运行时才能确定具体的类，这样该引用变量可以绑定到不同的对象上，导致该引用调用的方法也随之改变，程序可以选择多个运行状态，这就是多态。

## final相关知识点

- final修饰的成员变量必须显示赋值，系统不会对其进行隐形的初始化
- final修饰的成员变量为基本数据类型时，不能对其重新赋值，即该变量不能被改变
- final修饰的成员变量为引用变量时，仅限制其所引用地址不变，即一直指向同一个对象，但这个对象完全可以改变
- final修饰的方法不可以被重写，通常用于修饰父类中不想被子类重写的方法
- final修饰的类不可以被继承

## abstract相关知识点

- abstract修饰的类称为抽象类，可以包含抽象方法，不可创建实例对象，只可以当做父类被其他子类所继承
- 抽象类中可以包含构造方法， 但是构造方法不能被声明为抽象或者静态
- 抽象类不能用final来修饰，即一个类不能既是最终类又是抽象类
- 抽象类相当于一个模板，定义需要使用的某些方法，把不能实现的抽象成抽象方法
- 抽象方法只需申明，而无需实现，抽象类中可以允许普通方法有主体
- 抽象类定义了一个通用算法，不完全由其自身实现，而需要依赖子类可在其基础上进行扩展、改造
- 抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类

## 接口

- 接口中除了默认方法有实现体之外，不包括任何普通方法，所有的方法都是抽象方法（会默认添加 public abstract 修饰符）
- 接口不能包含构造函数、析构函数，不可被实例化
- 接口中不能包含常量、字段(域)、静态成员，可以有成员变量（会默认添加 public static final 修饰符）
- 一个接口可以继承多个父接口，可以获得父接口里定义的所有抽象方法、成员变量
- 一个类可以实现多个接口，implements 放在 extends 之后，多个接口逗号隔开
- 实现类必须实现接口中所有抽象方法，否则这个子类是抽象类

## 抽象类 & 接口

- 相同点：
    - 都位于继承树顶端，可用于被其他类实现和继承，不可以被实例化
    - 都包含抽象方法，实现类或子类必须实现这些抽象方法
- 不同点：
    - 接口只有抽象方法、静态方法、默认方法，不可为普通方法提供方法实现；抽象类则完全可以包含普通方法
    - 接口只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员，也可以定义静态常量
    - 接口不包含构造器；抽象类可以包含构造器，抽象类的构造器不是用来创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作